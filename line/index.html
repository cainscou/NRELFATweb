<!DOCTYPE html>
<html lang="en-US">
<head>

<meta charset="UTF-8" />
<title>NREL Line Graph Sample</title>

<meta name="keywords" content="Hydrogen, Fuel Cell, Fuel Cells, National Renewable
    Energy Lab, NREL, U.S. Department of Energy, DOE, Renewable Energy,
	Research, Technology Validation, Charts, Graphs" />
<meta name="description" content="NREL Interactive Web Graphics Template" />
<meta name="author" content="U.S. Department of Energy, National Renewable Energy Lab" />

<!-- Helps compatibility with IE 8 and earlier -->
<!--[if lt IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.js"></script>
<![endif

<!-- MAIN NREL STYLESHEET -->
<link rel="stylesheet" type="text/css" href="http://www.nrel.gov/includes/nrel.css" />

<!-- Local Styles for this WebPage -->
<style>

svg {
  font: 10px sans-serif;
}

.area {
  opacity: 0.9;
  clip-path: url(#clip);
  fill: steelblue;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
  clip-path: url(#clip);
  opacity: 0.9;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.axisLabel {
  font-size: 1.3em;
  
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}

noscript {
  font-size:150%;
  color:red;
  margin:30px;
}

</style>

</head>  
<body>

<!-- WEBPAGE HTML AND TEXT INFORMATION -->
<!-- Information displayed above the charts -->
<h2>Average $2010/kW Trend for Overall Deployments</h2>

<p>This graph represents the average cost per kilowatt of Fuel Cell deployments across the country</p>

<p><b>Instructions for Interactive Graphics:</b> <br /> <i> Click and drag on the lower graph to select the data range for the upper graph. <br /> This allows you to apply your own custom data filters and criteria!</i></p>

<!-- Additional spacing between text and graph -->
<p> <br /> <br /> </p>

<!-- Added this section in case JavaScript is not enabled on users web browser -->
<noscript><br />Sorry, JavaScript is either not enabled, or is not supported by your web browser.  <br />
		  Scripts must be enabled to see the interactive data visualizations on this page. <hr /> </noscript>
			   
<!-- D3 CHART LOCATION - D3 APPENDS CHART ELEMENTS INTO THIS DIV -->
<div id="charts"></div>


<!-- WEBAGE JAVASCRIPTS -->

<!-- Load the d3 Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<!-- Load JQuery - Not currently in use -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<!-- Main WebPage Script -->
<script>

// Put graphing script into function call to limit variable scopes.
NRELWebFat_Line();
function NRELWebFat_Line() {

// AJAX CALL FOR DATA DOWNLOAD, AND ADDING DATA INTO THE CHART:
// While the data is downloading, the next block of code after the d3.csv command will 
// execute.  Then, when all data has downloaded, the code inside the function passed 
// as an argument to d3.csv will execute.
d3.csv("cdp8_condensed.csv", type, function(error, data) {

  // DEFINE EACH LINE TO BE DRAWN ON THE CHART IN THE DATA STRUCTURE BELOW. 
  // Each line is an object in the array. This is in JSON format.
  /*
  Here is a DESCRIPTION of the different items in each line definition object:
	lineDef: This is where you define a d3.svg.line() object. See d3 documentation
			for more information. You need to call the .x and .y methods to define
			the data associated with the line. Use the format in the template as an example.
			Note: .x and .y are passed a function that accesses the data (data is passed
			to the line object later, this just defines what to do with the data when the 
			object is used. Within the function, the variables x and y are not the same as .x and .y.
			x and y refer to the d3 axis scaling objects previously defined.
	textLabel: This is just a text string that will be appended to each line on the chart to label the data.
	yData: This is a vector that specifies the y value data for the line (it is assumed x-value data is the same for
			all lines, so x data is defined in another location.). Some functionality later in the script need
			reference of what the y-data points associated with a line are.
	areaDef: This is where you define a d3.svg.area() object that draws the area curves on the lower subcharts.
			This lower chart is also where brushes are used to filter the graph based on time ranges.
			A similar process is used as in lineDef to define x and y data, except x2 and y2 are used for the d3 axis 
			scaling objects.
	lineColor: Specifies CSS attribute to define the color of the line in the upper chart.
	areaColor: Specifies CSS attribute to define the color of area in the lower chart where the time range can
			be filtered.
				
  */
		
  var lines = [

	// #line1 info - No incentives data
	{
	"lineDef": d3.svg.line()
					.x(function(d) { return x(d.year); })
					.y(function(d) { return y(d.cost_per_kW_NI); }),
	"yData": data.map(function(d) { return d.cost_per_kW_NI; }),
	"textLabel": 'No Incentive',
	"lineColor": "steelblue",
	
	"areaDef": d3.svg.area()
					.interpolate("monotone")
					.x(function(d) { return x2(d.year); })
					.y0(height2)
					.y1(function(d) { return y2(d.cost_per_kW_NI); }),
	"areaColor": "steelblue"
	},
		
	// #line2 info - With incentives data
	{
	"lineDef": d3.svg.line()
					.x(function(d) { return x(d.year); })
					.y(function(d) { return y(d.cost_per_kW_Incentive); }),
	"yData": data.map(function(d) { return d.cost_per_kW_Incentive; }), 
	"textLabel": 'With Incentive',
	"lineColor": "red",
	
	"areaDef": d3.svg.area()
					.interpolate("monotone")
					.x(function(d) { return x2(d.year); })
					.y0(height2)
					.y1(function(d) { return y2(d.cost_per_kW_Incentive); }),
	"areaColor": "firebrick"
	}
	
  ];

  // Defines some error handling if data file can not be loaded.
  if (error) { 
    d3.select("#charts").append("p").append("b")
    .text("The data file to produce interactive graphics could not be loaded."); 
    throw error;
  }
  // defines the domain of the data on each chart scale
  x.domain(d3.extent(data.map(function(d) { return d.year; })));
  y.domain([0, d3.max(data.map(function(d) { return d.cost_per_kW_NI; }))]);
  x2.domain(x.domain());
  y2.domain(y.domain());
	  
  // Draw the data curve lines into the main upper chart
  d3.select(".focus").selectAll("path")
		.data(lines)
	.enter().append("path")
		.attr("class", "line")
		.attr("id", function(d, i) { return "line" + (i + 1);} )
		.attr("d", function(d) { return d.lineDef(data); } )
		.attr("style", function(d) { return "stroke: " + d.lineColor + ";" ;})
		.datum(data)
		;
	  
  // Add text labels to each data line
  d3.select(".focus").selectAll("text")
		.data(lines)
	.enter().append("text")
		.attr("class", "dataLabel")
		.attr("id", function(d, i) {return "lineLabel" + (i+1); })
		.attr("text-anchor", "start")
		.attr("y", function(d) { return y(interp1(data.map(function(d) { return d.year; }), 
			d.yData, x.domain()[1])); } )
		.attr("x", width + 5)
		.attr("dy", ".71em")
		.text(function(d) { return d.textLabel;} );

  // Draw y - axis label
  focus.append("text")
	 .attr("class", "axisLabel")
	 .attr("transform", "rotate(-90)")
	 .attr("text-anchor", "end")
	 .attr("y", -margin.left+10)
	 .attr("x", -7)
	 .attr("dy", ".71em")
	 .text("Cost in $(2010) / kW");
  
  // Draw the x-axis onto the main upper chart
  focus.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

  // Draw the y-axis onto the main upper chart
  focus.append("g")
      .attr("class", "y axis")
      .call(yAxis);

  // Draw the data curves into the lower sub chart with brush filter
  d3.select(".context").selectAll(".area")
		.data(lines)
	.enter().append("path")
		.attr("class", "area")
		.attr("id", function(d, i) { return "area" + (i + 1);} )
		.attr("d", function(d) { return d.areaDef(data); } )
		.attr("style", function(d) { return "stroke: " + d.areaColor + "; fill: " + d.areaColor + ";" ;})
		.datum(data)
		; 

  // Draw the x-axis onto the lower sub chart with brush filters
  context.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height2 + ")")
      .call(xAxis2);

  // Adds the interactive brush into the lower sub chart so data can be filtered
  var brush = d3.svg.brush()
		.x(x2)
		.on("brush", brushed);
		
  context.append("g")
      .attr("class", "x brush")
      .call(brush)
    .selectAll("rect")
      .attr("y", -6)
      .attr("height", height2 + 7);
  
  // SUB-FUNCTION DEFINITIONS:
  // These are within the AJAX call because they need to access variables within the same scope, such as data.

	// This function executes when the brush is used to redefine the x-axis scale.
	function brushed() {
	  // reset x axis domain based on brush extent
	  x.domain(brush.empty() ? x2.domain() : brush.extent());
	  
	  // update lines on chart based on new x domain. (note: x domain is built into line definition).
		d3.select(".focus").selectAll("path")
			.data(lines)
			.attr("d", function(d) { return d.lineDef(data); } )
			.datum(data)
			;
	  
	  // Update line text labels based on new x domain. The interp1 function is used so text labels follow 
	  // the end of their corresponding line as it moves based on the data range.
	  d3.select(".focus").selectAll(".dataLabel")
			.data(lines)
			.attr("y",  function(d) { return y(interp1(data.map(function(d) { return d.year; }), 
				d.yData, x.domain()[1])); });
	  
	  /*
	  focus.select("#line1-label").attr("y",  y(interp1(data.map(function(d) { return d.year; }), 
		data.map(function(d) { return d.cost_per_kW_NI; }), x.domain()[1])));
	  focus.select("#line2-label").attr("y",  y(interp1(data.map(function(d) { return d.year; }), 
		data.map(function(d) { return d.cost_per_kW_Incentive; }), x.domain()[1])));
	  */
		
	  // Update x-axis based on brush extent / new data range.
	  focus.select(".x.axis").call(xAxis);
	}
  
}); // end of d3.csv asynchronous call


// THIS SECTION INITIALIZES VARIABLES THAT DEFINE THE CHART:
// This runs immediately after the data download in d3.csv begins, 
// and before any code within the d3.csv asynchronous call begins.

// Defines chart dimensions
var margin = {top: 10, right: 150, bottom: 135, left: 70},
    margin2 = {top: 430, right: 150, bottom: 60, left: 70},
    width = 960 - margin.left - margin.right,
    height = 540 - margin.top - margin.bottom,
    height2 = 540 - margin2.top - margin2.bottom;

// Defines function to convert timestamps into JavaScript date format
var parseDate = d3.time.format("%Y").parse;

// Define d3 scales for the chart axes.
var x = d3.time.scale().range([0, width]),
    x2 = d3.time.scale().range([0, width]),
    y = d3.scale.linear().range([height, 0]),
    y2 = d3.scale.linear().range([height2, 0]);

// Define d3 functions that construct chart axes.
var xAxis = d3.svg.axis().scale(x).orient("bottom"),
    xAxis2 = d3.svg.axis().scale(x2).orient("bottom"),
    yAxis = d3.svg.axis().scale(y).orient("left");


	
// THIS SECTION BEGINS CONSTRUCTING A SKELETON FOR THE CHART:
// The skeleton will be filled in once the rest of the data loads.

// Creates SVG graphic of appropriate size
var svg = d3.select("#charts").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom);

// Append clipPath
svg.append("defs").append("clipPath")
    .attr("id", "clip")
  .append("rect")
    .attr("width", width)
    .attr("height", height);

// Append g tag to define main chart area
var focus = svg.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// Append g tag to define lower sub chart chart with filters.
var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

// Append label to x-axis	
context.append("text")
  .attr("class", "axisLabel")
  .attr("text-anchor", "end")
  .attr("y", height2 + margin2.bottom - 40)
  .attr("x", width - 7)
  .attr("dy", ".71em")
  .text("Year");	


// SUB-FUNCTION DEFINITIONS:

// This function executes when data is initially loaded to 
// convert the variable data types from strings.
function type(d) {
  d.year = parseDate(d.year);
  d.cost_per_kW_NI = +d.cost_per_kW_NI;
  d.cost_per_kW_Incentive = +d.cost_per_kW_Incentive;
  return d;
}

// Custom function to perform an interpolation between two arrays of number.
// Same concept as interp1 function in MATLAB
function interp1(arrayX, arrayY, xTest) {
  // > You can think of this function as performing a linear interpolation 
  // on a line chart.  arrayX and arrayY are equal length vectors that
  // define data points on a chart.  xTest is an X data point somewhere in
  // between the chart data points, and we want to interpolate a Y value that 
  // corresponds to xTest.
  // > It is assumed arrayX is a sorted array (ascending or descending) order.
  // > arrayY can be in any order, as these are just data points
  // in a different dimension that correspond to each data point
  // in arrayX.
  // > xTest is a single data point in the X dimension that needs to 
  // be interpolated. This function finds the location of X between 
  // data points in arrayX, and then calculates the corresponding
  // yResult based on linear interpolation in arrayY.
  
  // Initialize function variables
  var yResult = NaN; // output value
  var errorFlag = false; // flag that indicates invalid input values  
  var highVal, lowVal, index;
  
  
  // CHECK THAT INPUTS ARE VALID:
  errorFlag = false;
  
  // Check if inputs are defined
  if (arrayX === undefined || arrayY === undefined || xTest === undefined) errorFlag = true;
  
  if (!errorFlag) {
	  // Check if arrayX and arrayY are the same length
	  if (arrayX.length != arrayY.length) errorFlag = true;
	  
	  // Check if both arrayX and arrayY have at least two elements
	  if (arrayX.length < 2) errorFlag = true;
	  
	  // Check if arrayX is sorted in descending order. If so, reverse input arrays so function still works.
	  // Interpolation algorithm is designed to work on ascending arrays only.
	  if (arrayX[1] - arrayX[0] < 0) { arrayX.reverse(); arrayY.reverse(); };
	  
	  // Check if xTest is within the range of arrayX.  This function is only designed to perform data point,
	  // interpolation. It does not extrapolate data points!
	  if (!errorFlag && (xTest + 0.00001 < arrayX[0] || xTest - 0.00001 > arrayX[arrayX.length - 1] )) errorFlag = true ;
  }
  
  // IF INPUTS ARE GOOD, CALCULATE RESULTS:
  if (!errorFlag) {
	  // Loop through each element of arrayX to find which data
	  // points xTest is between. Find index of this location.

	  // Binary search algorithm to locate which data points xTest is located between in arrayX
	  highVal = arrayX.length - 1;
	  lowVal = 0;
	  index = Math.ceil((arrayX.length - 1) / 2 + lowVal);
	  while( !(arrayX[index] >= xTest && arrayX[index - 1] <= xTest) ) {
		if (arrayX[index] > xTest) {
			highVal = index;
		} else {
			lowVal = index;
		}
		index = Math.ceil((highVal - lowVal)/2 + lowVal);
		
		/*
		// not sure if needed, but for small intervals I was worried that index and highVal would be equal when binary
		if (index == highVal) { index-- }; 
		*/
	  }
	  
	  /*
	  // Old search algorithm  - less efficient for large datasets but simpler code
	  for (index = 0; arrayX[index] <= xTest; index++) {};
	  */
	  
	  // Small correction for boundary conditions. If index is 0 or 1 past end
	  // of array, input xTest may be right at the boundary of the domain defined
	  // by arrayX, but index value will be past the range of acceptable values for
	  // the algorithm. We want to make sure the interpolation function works with 
	  // these values as well.
	  if (index == 0) index++;
	  if (index == arrayX.length) index--;
	  
	  // Interpolation formula. index defines high valued reference data point, and index - 1 
	  // defines low valued reference data point.
	  yResult = ((xTest - arrayX[index - 1])/(arrayX[index] - arrayX[index - 1])) * 
		  (arrayY[index] - arrayY[index - 1]) + arrayY[index - 1];
		  
  } else {
	console.log("WARNING: Invalid inputs into interp1 function");
  }

  return yResult;
}

}// END OF MAIN WEBPAGE SCRIPT and NRELWebFat_Line Function Call

</script>

</body>
</html>
